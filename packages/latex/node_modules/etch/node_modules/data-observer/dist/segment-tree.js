var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _Random = require('random-seed');

var _Random2 = _interopRequireWildcard(_Random);

var _SegmentTreeNode = require('./segment-tree-node');

var _SegmentTreeNode2 = _interopRequireWildcard(_SegmentTreeNode);

'use babel';

var NOT_DONE = { done: false };
var DONE = { done: true };

var SegmentTree = (function () {
  function SegmentTree() {
    var randomSeed = arguments[0] === undefined ? Date.now() : arguments[0];

    _classCallCheck(this, SegmentTree);

    this.randomSeed = randomSeed;
    this.randomGenerator = new _Random2['default'](randomSeed);
    this.root = null;
  }

  _createClass(SegmentTree, [{
    key: 'buildIterator',
    value: function buildIterator() {
      return new SegmentTreeIterator(this);
    }
  }, {
    key: 'buildIteratorAtStart',
    value: function buildIteratorAtStart() {
      return new SegmentTreeIterator(this, true);
    }
  }, {
    key: 'splice',
    value: function splice(outputStart, removedCount, addedCount) {
      var outputEnd = outputStart + removedCount;
      var spliceDelta = addedCount - removedCount;

      var startNode = this.insertSpliceBoundary(outputStart, true);
      var endNode = this.insertSpliceBoundary(outputEnd, false);
      startNode.priority = -1;
      this.bubbleNodeUp(startNode);
      endNode.priority = -2;
      this.bubbleNodeUp(endNode);

      startNode.right = null;
      startNode.inputExtent = startNode.inputLeftExtent;
      startNode.outputExtent = startNode.outputLeftExtent;

      endNode.outputLeftExtent += spliceDelta;
      endNode.outputExtent += spliceDelta;

      startNode.priority = this.generateRandom();
      this.bubbleNodeDown(startNode);
      endNode.priority = this.generateRandom();
      this.bubbleNodeDown(endNode);
    }
  }, {
    key: 'insertSpliceBoundary',
    value: function insertSpliceBoundary(boundaryOutputIndex, insertingChangeStart) {
      var insertingChangeEnd = !insertingChangeStart;

      var node = this.root;

      if (!node) {
        this.root = new _SegmentTreeNode2['default'](null, boundaryOutputIndex, boundaryOutputIndex);
        this.root.isChangeStart = insertingChangeStart;
        this.root.isChangeEnd = insertingChangeEnd;
        return this.root;
      }

      var inputOffset = 0;
      var outputOffset = 0;
      var maxInputIndex = Infinity;
      var nodeInputIndex = undefined,
          nodeOutputIndex = undefined;
      var closestStartNode = undefined,
          closestEndNode = undefined;

      while (true) {
        nodeInputIndex = inputOffset + node.inputLeftExtent;
        nodeOutputIndex = outputOffset + node.outputLeftExtent;

        if (node.isChangeStart) {
          var _node = visitChangeStart();
          if (_node) {
            return _node;
          }
        } else {
          var _node2 = visitChangeEnd();
          if (_node2) {
            return _node2;
          }
        }
      }

      function visitChangeStart() {
        if (boundaryOutputIndex < nodeOutputIndex) {
          if (node.left) {
            closestEndNode = null;
            descendLeft();
          } else {
            return insertLeftNode();
          }
        } else {
          // boundaryOutputIndex >= nodeOutputIndex
          if (node.right) {
            closestStartNode = node;
            descendRight();
          } else {
            if (insertingChangeStart) {
              return node;
            } else {
              // insertingChangeEnd
              if (closestEndNode) {
                return closestEndNode;
              } else {
                return insertRightNode();
              }
            }
          }
        }
      }

      function visitChangeEnd() {
        if (boundaryOutputIndex <= nodeOutputIndex) {
          if (node.left) {
            closestEndNode = node;
            descendLeft();
          } else {
            if (insertingChangeStart) {
              if (closestStartNode) {
                return closestStartNode;
              } else {
                return insertLeftNode();
              }
            } else {
              // insertingChangeEnd
              return node;
            }
          }
        } else {
          // boundaryOutputIndex > nodeOutputIndex
          if (node.right) {
            closestStartNode = null;
            descendRight();
          } else {
            return insertRightNode();
          }
        }
      }

      function descendLeft() {
        maxInputIndex = nodeInputIndex;
        node = node.left;
      }

      function descendRight() {
        inputOffset += node.inputLeftExtent;
        outputOffset += node.outputLeftExtent;
        node = node.right;
      }

      function insertLeftNode() {
        var outputLeftExtent = boundaryOutputIndex - outputOffset;
        var inputLeftExtent = Math.min(outputLeftExtent, node.inputLeftExtent);
        var newNode = new _SegmentTreeNode2['default'](node, inputLeftExtent, outputLeftExtent);
        newNode.isChangeStart = insertingChangeStart;
        newNode.isChangeEnd = insertingChangeEnd;
        node.left = newNode;
        return newNode;
      }

      function insertRightNode() {
        var outputLeftExtent = boundaryOutputIndex - nodeOutputIndex;
        var inputLeftExtent = Math.min(outputLeftExtent, maxInputIndex - nodeInputIndex);
        var newNode = new _SegmentTreeNode2['default'](node, inputLeftExtent, outputLeftExtent);
        newNode.isChangeStart = insertingChangeStart;
        newNode.isChangeEnd = insertingChangeEnd;
        node.right = newNode;
        return newNode;
      }
    }
  }, {
    key: 'bubbleNodeUp',
    value: function bubbleNodeUp(node) {
      while (node.parent && node.priority < node.parent.priority) {
        if (node === node.parent.left) {
          this.rotateNodeRight(node);
        } else {
          this.rotateNodeLeft(node);
        }
      }
    }
  }, {
    key: 'bubbleNodeDown',
    value: function bubbleNodeDown(node) {
      while (true) {
        var leftChildPriority = node.left ? node.left.priority : Infinity;
        var rightChildPriority = node.right ? node.right.priority : Infinity;

        if (leftChildPriority < rightChildPriority && leftChildPriority < node.priority) {
          this.rotateNodeRight(node.left);
        } else if (rightChildPriority < node.priority) {
          this.rotateNodeLeft(node.right);
        } else {
          break;
        }
      }
    }
  }, {
    key: 'rotateNodeLeft',
    value: function rotateNodeLeft(pivot) {
      var root = pivot.parent;

      if (root.parent) {
        if (root === root.parent.left) {
          root.parent.left = pivot;
        } else {
          root.parent.right = pivot;
        }
      } else {
        this.root = pivot;
      }
      pivot.parent = root.parent;

      root.right = pivot.left;
      if (root.right) {
        root.right.parent = root;
      }

      pivot.left = root;
      pivot.left.parent = pivot;

      pivot.inputLeftExtent = root.inputLeftExtent + pivot.inputLeftExtent;
      pivot.inputExtent = pivot.inputLeftExtent + (pivot.right ? pivot.right.inputExtent : 0);
      root.inputExtent = root.inputLeftExtent + (root.right ? root.right.inputExtent : 0);

      pivot.outputLeftExtent = root.outputLeftExtent + pivot.outputLeftExtent;
      pivot.outputExtent = pivot.outputLeftExtent + (pivot.right ? pivot.right.outputExtent : 0);
      root.outputExtent = root.outputLeftExtent + (root.right ? root.right.outputExtent : 0);
    }
  }, {
    key: 'rotateNodeRight',
    value: function rotateNodeRight(pivot) {
      var root = pivot.parent;

      if (root.parent) {
        if (root === root.parent.left) {
          root.parent.left = pivot;
        } else {
          root.parent.right = pivot;
        }
      } else {
        this.root = pivot;
      }
      pivot.parent = root.parent;

      root.left = pivot.right;
      if (root.left) {
        root.left.parent = root;
      }

      pivot.right = root;
      pivot.right.parent = pivot;

      root.inputLeftExtent = root.inputLeftExtent - pivot.inputLeftExtent;
      root.inputExtent = root.inputExtent - pivot.inputLeftExtent;
      pivot.inputExtent = pivot.inputLeftExtent + root.inputExtent;

      root.outputLeftExtent = root.outputLeftExtent - pivot.outputLeftExtent;
      root.outputExtent = root.outputExtent - pivot.outputLeftExtent;
      pivot.outputExtent = pivot.outputLeftExtent + root.outputExtent;
    }
  }, {
    key: 'generateRandom',
    value: function generateRandom() {
      return this.randomGenerator.random();
    }
  }, {
    key: 'toHTML',
    value: function toHTML() {
      return this.root.toHTML();
    }
  }]);

  return SegmentTree;
})();

exports['default'] = SegmentTree;

var SegmentTreeIterator = (function () {
  function SegmentTreeIterator(tree, rewind) {
    _classCallCheck(this, SegmentTreeIterator);

    this.tree = tree;
    this.inputOffset = 0;
    this.outputOffset = 0;
    this.inputOffsetStack = [];
    this.outputOffsetStack = [];
    this.setNode(tree.root);

    if (rewind && this.node) {
      while (this.node.left) {
        this.descendLeft();
      }
    }
  }

  _createClass(SegmentTreeIterator, [{
    key: 'getInputStart',
    value: function getInputStart() {
      return this.inputStart;
    }
  }, {
    key: 'getInputEnd',
    value: function getInputEnd() {
      return this.inputEnd;
    }
  }, {
    key: 'getOutputStart',
    value: function getOutputStart() {
      return this.outputStart;
    }
  }, {
    key: 'getOutputEnd',
    value: function getOutputEnd() {
      return this.outputEnd;
    }
  }, {
    key: 'inChange',
    value: function inChange() {
      return !!this.node && this.node.isChangeEnd;
    }
  }, {
    key: 'setNode',
    value: function setNode(node) {
      this.node = node;

      if (node) {
        if (node.left) {
          this.inputStart = this.inputOffset + node.left.inputExtent;
          this.outputStart = this.outputOffset + node.left.outputExtent;
        } else {
          this.inputStart = this.inputOffset;
          this.outputStart = this.outputOffset;
        }

        this.inputEnd = this.inputOffset + node.inputLeftExtent;
        this.outputEnd = this.outputOffset + node.outputLeftExtent;
      } else {
        this.inputStart = 0;
        this.inputEnd = Infinity;
        this.outputStart = 0;
        this.outputEnd = Infinity;
      }
    }
  }, {
    key: 'next',
    value: function next() {
      if (!this.node) {
        return DONE;
      }

      if (this.node.right) {
        this.descendRight();
        while (this.node.left) {
          this.descendLeft();
        }
        return NOT_DONE;
      } else {
        while (this.node.parent && this.node.parent.right === this.node) {
          this.ascend();
        }
        if (this.node.parent) {
          this.ascend();
          return NOT_DONE;
        } else {
          return DONE;
        }
      }
    }
  }, {
    key: 'ascend',
    value: function ascend() {
      this.inputOffset = this.inputOffsetStack.pop();
      this.outputOffset = this.outputOffsetStack.pop();
      this.setNode(this.node.parent);
    }
  }, {
    key: 'descendLeft',
    value: function descendLeft() {
      this.inputOffsetStack.push(this.inputOffset);
      this.outputOffsetStack.push(this.outputOffset);
      this.setNode(this.node.left);
    }
  }, {
    key: 'descendRight',
    value: function descendRight() {
      this.inputOffsetStack.push(this.inputOffset);
      this.outputOffsetStack.push(this.outputOffset);
      this.inputOffset += this.node.inputLeftExtent;
      this.outputOffset += this.node.outputLeftExtent;
      this.setNode(this.node.right);
    }
  }]);

  return SegmentTreeIterator;
})();

module.exports = exports['default'];